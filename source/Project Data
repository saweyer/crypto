// Crypto 1.1// Copyright 1997-98. S. Weyer. All Rights Reserved Worldwideconstant kVersionNum  	:= "1.1";constant kBetaVersion 	:= "";DeclareGlobalFn('DeclareGlobalFn, 2);DeclareGlobalFn('DefineGlobalConstant,2);DeclareGlobalFn('IsGlobalConstant,1);DefineGlobalConstant('kVersionString,	kVersionNum & kBetaVersion &	(if kDebugOn then $D) &	(if kProfileOn then $P) &	(if not kIgnoreNativeKeyword then $N));DefineGlobalConstant('kTitle, kAppName && kVersionString);DefineGlobalConstant('kVersion, if kDebugOn then kTitle && DateNTime(Time()) else kTitle);Print(kVersion && DateNTime(time()));Print(kAppSymbol);DefineGlobalConstant('kNameSym, 	Intern(kAppName));DefineGlobalConstant('kSoupName,	SPrintObject(kAppSymbol));DefineGlobalConstant('kUPNAME,		UPCASE(Clone(kAppName)));DefineGlobalConstant('kDocFileName, Downcase(SubStr(kAppName,0,5)) & "doc"); // cryptdocDefineGlobalConstant('kBookISBN, 	kDocFileName & ".htm");DefineGlobalConstant('kDocPkg, 		kDocFileName & ".pkg");constant kNewtsCapeSym := 			'|NewtsCape:NewtsCape|;constant kNewtsCapeName := 			"Newt's Cape";constant kOpen	:=					"Open";constant cr := "\n";DefineGlobalConstant('kAboutText,kTitle & cr & cr &kAppName && "supports solving cryptogram, code,cipher (single character substitution) puzzleslike those in newspapers.  For directions,see Help," && kBookISBN & $, && kDocPkg & "" &kAppName && "is shareware ($10) \u00A9\u1997-98,S. Weyer. After several days of trial use,please register.Steve Weyer17 Timber Knoll Dr.Washington Crossing, PA 18977-1052Internet: <A HREF=\"mailto:weyer@kagi.com\">weyer@kagi.com</A>AOL, CIS: SteveWeyer<A HREF=\"http://members.bellatlantic.net/~sweyer/newton/index.htm\">http://members.bellatlantic.net/~sweyer/newton/index.htm</A>");DefineGlobalConstant('kSampleText,"WELCOME TO" && kUPNAME &". THIS WILL APPEAR IN CODE FOR YOU TO SOLVE. HAVE FUN!");DefineGlobalConstant('kHelpText,"To Enter Code¥ write (no kbd) uppercase letters directly inanswer; or select a cell and tap top A-Z row¥ Encode 'answer' and Move it to code area¥ drop Notepad/Newtworks text to answer/code¥ use crypex**.htm/.pkg Newton docs/books¥ tap" && kAppName && "in Notepad/Newtworks:Tools menu¥ xfer crypex**.slp to Crypto Soup with SlurpeeTo Edit Answer¥ overwrite/scrub/Undo a letter; tap to Clear;Clear Answer only, or Delete answer&code¥" && kAppName && "beeps if letter already used,or substitutes and shows used letters at top¥ ? reveals an answer letter (if available)More info:" && kBookISBN & $, && kDocPkg);DefineGlobalConstant('kDrawStyle,	// for AZkey, protoCharEdit	{font: ROM_fontSystem10,	justification: 'center});DefineGlobalConstant('kDrawStyleR,	// for AZfreq	{font: ROM_fontSystem10,	justification: 'right});constant kDrawWidth  := 10; // M,W widerconstant kDrawHeight := 11;constant kDrawOffsetY:=  2;constant kCellWidth 	:= 22;	// width of a cell  (wide enough for M & W)constant kCellHeight	:= 33;	// for protoCharEdit (high enough for code underneath. viewLineSpacing+11)DefineGlobalConstant('kTopMargin, (2 * kDrawHeight) - kDrawOffsetY);	// ok to overlap a littleDefineGlobalConstant('kBotMargin, 2 * kDrawHeight); 	// status barconstant kSpace	 		:= $ ;constant kHelpChar		:= $?;constant kTooLongChar	:= $É;constant kBreakWordChar	:= $~;constant kNotEditable	:= $_;DefineGlobalConstant('kAupper, Ord($A));DefineGlobalConstant('kAlower, Ord($a));constant kNumLetters:= 26;constant kLastLetter:= 25;	// kNumLetters-1constant kAlphabet	:= "ABCDEFGHIJKLMNOPQRSTUVWXYZ";DefineGlobalConstant('kAlphaPunc, kAlphabet & "?.,:;'()-!~\"");	// full editingDefineGlobalConstant('kAlphabetQ, kAlphabet & kHelpChar);		// code editing w/ answerconstant kBookReaderSymbol		:= 'Copperfield;//constant kHelpReaderSymbol	:= 'tinyTim;DefineGlobalConstant('kMakeString, func(INT slen, fillCh) // like MakeArraybegin	local str := MakeBinary((slen*2) + 2, 'string);	local INT i;	if fillCh	then for i:=0 to slen-1 do str[i] := fillCh;	str;end);/*DefineGlobalConstant('kUpchar, func(ch)begin	local INT code := Ord(ch) - kAlower;	if code >= 0 and code <= kLastLetter	then kAlphabet[code]	//Chr(code + kAupper)	else ch;end);*/DefineGlobalConstant('kMyUpTrimString, func(str)if IsString(str)then begin	// get rid of leading, trailing and extra blanks in middle	// but also convert cr,tab to space; lowercase to uppercase	str := StripInk(Clone(str), nil);	local INT slen := StrLen(str), i := 0, code;	local del, ch;	while i < slen	do begin		if isWhiteSpace(ch := str[i])		then begin			if not del			then str[del := i] := kSpace; // remember first "space" (convert)			end		else begin			//str[i] := call kUpchar with (ch);			if (code := Ord(ch) - kAlower) >= 0 and code <= kLastLetter			then str[i] := kAlphabet[code];			if del and (del=0 or (del := del+1) < i)			then begin				StrMunger(str, del, i-del, nil,0,nil);				slen := slen-i+del; //StrLen(str);				i := del-1;	// +1 below				end;			del := nil;			end;		i := i+1;		end;	if del	// trim end	then StrMunger(str,del,nil, nil,0,nil);	str;	endelse str);DefineGlobalConstant('kStrBreakPos, func(str, INT spos, INT charWid)begin	// return next "line" break position, given max charWid chars per line	local INT slast := spos+charWid, slen := StrLen(str), i;	if slast < slen	then begin // break on whitespace, end or -		if isWhiteSpace(str[slast])		then return slast;		for i := slast-1 to spos by -1		do if not isAlphaNumeric(str[i])		then return i;		return slast-1;	// break arbitrarily		end;end);// usually called via AddDeferredCallDefineGlobalConstant('kResetLetters, func() // shared by viewSetupFormScript, setTextCodeGetRoot().(kAppSymbol).lettersUsed := Array(kNumLetters, NIL));/*DefineGlobalConstant('kIsUpper, func(ch)begin	//CharPos(kAlphabet, ch, 0)	local INT code := Ord(ch) - kAupper;	if code >= 0 and code <= kLastLetter	then code;end);*/// ----------// RegisterDefineGlobalConstant('kGetResource, func(name)begin	local rsc := OpenResFileX(HOME & kAppName & ".rsc");	local icon := GetPictAsBits(name,nil);	CloseResFileX(rsc);	icon;end);constant kRegistrationPackage := '|Register:FlaSheridn|;constant kSharewareFee := 10.00;DefineGlobalConstant('kRegisterIcon, call kGetResource with ("RegisterMoneyButton"));DefineGlobalConstant('kRegFrame,	{package: kAppSymbol, 	price:	  kSharewareFee,	platform: 'Newton, 	Version:  kVersionString,	notes:	 "Thanks for registering" && kAppName,	});// ----------// Notesconstant kNotesSym 			:= 'paperroll;constant kNotesName			:= "Notes";DefineGlobalConstant ('kSourcePath,'[pathExpr: data,0,text]);DefineGlobalConstant('kNotesGetTitle, func(target)// for GetTitle slot of routeframeif target and IsString(target.(kSourcePath))then kAppName);DefineGlobalConstant('kNotesRouteScript, func(target,targetView)if targetthen begin	local root := GetRoot();	root.(kNotesSym):close();	root.(kAppSymbol):newCode(kNotesName & $: && target.title, nil, target.(kSourcePath), nil);	end);DefineGlobalConstant('kNotesRouteItem, { // for routeScript array (GetRouteScripts)GetTitle: 			kNotesGetTitle,icon:				call kGetResource with ("cipherSmallicon"), // rename?tag:				kAppSymbol,routeScript:		kNotesRouteScript,});DefineGlobalConstant('kNotesProtoItem, { // for Notes _proto chainGetRouteScripts:	func(targetInfo)begin	local routes := [kNotesRouteItem], oldRoutes;	if oldRoutes := inherited:?GetRouteScripts(targetInfo)	then routes := SetUnion(routes, oldRoutes, true);	SetUnion(routes, routeScripts, true);end});// ----------// NewtWorksconstant kNewtWorksSym		:= 'NewtWorks;constant kNewtWorksName		:= "NewtWorks";DefineGlobalConstant('kNewtWorksDoItFunc, func(viewDefView, newtAppBase)	// newtAppBase is unusedbegin	// check if anything is selected	local range := viewDefView:GetHiliteRange();	// if nothing is selected, treat it as 'Select All'	if range.first = range.last	then begin	  	range.first := 0 ;	  	range.last 	:= viewDefView:GetCountCharacters() ;		end;	local str := viewDefView:GetRangeData(range, 'text);	local title := newtAppBase.target.title;	//local root := GetRoot();	newtAppBase:close(); //root.(kNewtWorksSym):close();	GetRoot().(kAppSymbol):newCode(kNewtWorksName & $: && title, nil, str, nil);end);DefineGlobalConstant('kToolFrame,	{ // see Rot13 exampledataTypeSymbol: 'paper,		// REQUIRED: ('paper for word processor; 'drawPaper for drawing app)item: 			kAppName,	// REQUIRED: appears in popup in tool picker./*keyCommand: {				// optional	char:		$1,			// cmd-!	showchar:	$!,	modifiers:	kCommandModifier,	//1 << 25	keyMessage:	Intern("Do" & kAppName),	keyFn:		func(viewDefView)					call kNewtWorksDoItFunc with (viewDefView, nil),	// newtAppBase is unused	name:		kAppName,	category:	"General",	},*/// REQUIRED: called when user selects the item in the Tools pickercmdFunc:	kNewtWorksDoItFunc,});// ----------// Extrasconstant kExtrasSym	:= 'extrasDrawer;DefineGlobalConstant('kExtrasProtoItem, { // for Extras _proto chaingetIndex: func(dropPt) // return index into visibleItemsbegin	local INT index := (dropPt.y - :GlobalBox().top - 22) div vSpacing;	if overUp	then index	// overview	else begin	// icon view		local lb := :LocalBox(), cols := (lb.right - lb.left) div hSpacing;		(index * cols) + (dropPt.x div hSpacing);		end;end,viewGetDropTypesScript: func(dropPt)begin//Print(dropPt);	local INT index := :getIndex(dropPt);//Print(index);	if index >= 0 and index < Length(visibleItems)		and visibleItems[index].fEntry.app = kAppSymbol	then begin		local app := GetRoot().(kAppSymbol);		app.extrasIndex := index;	// stash for viewDropScript test		app:viewGetDropTypesScript(dropPt);		end	else inherited:?viewGetDropTypesScript(dropPt);end,viewFindTargetScript: func(dragInfo)if SetContains(dragInfo[0].types, 'text)then selfelse inherited:?viewFindTargetScript(dragInfo),//viewDragFeedBackScript:	func(dragInfo,currentPoint,show) nil,	// no drawing occurredviewDropScript: func(dropType, dropData, dropPt)begin	local app := GetRoot().(kAppSymbol);	if app.extrasIndex = :getIndex(dropPt)	then app:newCode("drop app(code)", nil, dropData.text, nil)	else inherited:?viewDropScript(dropType, dropData, dropPt);end,//viewDropDoneScript:		func() nil,});// ----------DefineGlobalConstant ('kAddPatchFunc, func(target, template)if targetthen begin	// init the patch	local patch := EnsureInternal({}), sym, val;	// copy all of the patched slots (including tag)	foreach sym, val in template	do patch.(EnsureInternal(sym)) := val;	patch.(EnsureInternal('tag)) := EnsureInternal(kAppSymbol);	// link into the target's proto chain	patch.(EnsureInternal('_proto)) := target._proto;	target._proto := patch; // returns patch	end);DefineGlobalConstant('kRemovePatchFunc, func(target)begin	local nextProto;	if target	then while nextProto := target._proto	do  if nextProto.tag = kAppSymbol		then break target._proto := nextProto._proto		else target := nextProto;end);// ----------InstallScript := func(partFrame)begin	local root := GetRoot();	call kAddPatchFunc with (root.(kNotesSym),   kNotesProtoItem);	call kAddPatchFunc with (root.(kExtrasSym), kExtrasProtoItem);	root.(kNewtWorksSym):?RegNewtWorksTool(EnsureInternal(kAppSymbol), kToolFrame);	//if kDebugOn then	//AddDeferredCall(func() root.(kAppSymbol):open(), nil);end;RemoveScript := func(partFrame)begin	local root := GetRoot();	call kRemovePatchFunc with (root.(kNotesSym));	call kRemovePatchFunc with (root.(kExtrasSym));	root.(kNewtWorksSym):?UnRegNewtWorksTool(kAppSymbol);end;/* TO DO?- insert gesture/drag letters to move over?- mask for cipherIcon?- lowercase testing- performance*//*getroot().|Crypto:TKnollSys|.codearea:getchildviews()[0]*/