// Text of project Crypto.¹ written on 2/14/98 at 10:59 AM
// Beginning of text file Project Data
// Crypto 1.1
// Copyright 1997-98. S. Weyer. All Rights Reserved Worldwide


constant kVersionNum  	:= "1.1";
constant kBetaVersion 	:= "";

DeclareGlobalFn('DeclareGlobalFn, 2);
DeclareGlobalFn('DefineGlobalConstant,2);
DeclareGlobalFn('IsGlobalConstant,1);

DefineGlobalConstant('kVersionString,
	kVersionNum & kBetaVersion &
	(if kDebugOn then $D) &
	(if kProfileOn then $P) &
	(if not kIgnoreNativeKeyword then $N)
);
DefineGlobalConstant('kTitle, kAppName && kVersionString);
DefineGlobalConstant('kVersion
Å‚xÅ‚@, if kDebugOn then kTitle && DateNTime(Time()) else kTitle);

Print(kVersion && DateNTime(time()));
Print(kAppSymbol);

DefineGlobalConstant('kNameSym, 	Intern(kAppName));
DefineGlobalConstant('kSoupName,	SPrintObject(kAppSymbol));
DefineGlobalConstant('kUPNAME,		UPCASE(Clone(kAppName)));
DefineGlobalConstant('kDocFileName, Downcase(SubStr(kAppName,0,5)) & "doc"); // cryptdoc
DefineGlobalConstant('kBookISBN, 	kDocFileName & ".htm");
DefineGlobalConstant('kDocPkg, 		kDocFileName & ".pkg");

constant k
Å‚xÅ‚@NewtsCapeSym := 			'|NewtsCape:NewtsCape|;
constant kNewtsCapeName := 			"Newt's Cape";
constant kOpen	:=					"Open";

constant cr := "\n";

DefineGlobalConstant('kAboutText,
kTitle & cr & cr &

kAppName && "supports solving cryptogram, code,
cipher (single character substitution) puzzles
like those in newspapers.  For directions,
see Help," && kBookISBN & $, && kDocPkg & "

" &
kAppName && "is shareware ($10) \u00A9\u1997-98,
S. Weyer. After several days of trial use,
please register.

Steve Weyer
1
Å‚xÅ‚@7 Timber Knoll Dr.
Washington Crossing, PA 18977-1052
Internet: <A HREF=\"mailto:weyer@kagi.com\">weyer@kagi.com</A>
AOL, CIS: SteveWeyer
<A HREF=\"http://members.bellatlantic.net/~sweyer/newton/index.htm\">http://members.bellatlantic.net/~sweyer/newton/index.htm</A>");


DefineGlobalConstant('kSampleText,
"WELCOME TO" && kUPNAME &
". THIS WILL APPEAR IN CODE FOR YOU TO SOLVE. HAVE FUN!"
);


DefineGlobalConstant('kHelpText,
"To Enter Code
¥ write (no kbd) uppercase letters directly in
answer; or sel
Å‚xÅ‚@ect a cell and tap top A-Z row
¥ Encode 'answer' and Move it to code area
¥ drop Notepad/Newtworks text to answer/code
¥ use crypex**.htm/.pkg Newton docs/books
¥ tap" && kAppName && "in Notepad/Newtworks:Tools menu
¥ xfer crypex**.slp to Crypto Soup with Slurpee

To Edit Answer
¥ overwrite/scrub/Undo a letter; tap to Clear;
Clear Answer only, or Delete answer&code
¥" && kAppName && "beeps if letter already used,
or substitutes and shows used letters at top
¥ ? reveals an answer letter (if available)
Å‚xÅ‚@

More info:" && kBookISBN & $, && kDocPkg);



DefineGlobalConstant('kDrawStyle,	// for AZkey, protoCharEdit
	{font: ROM_fontSystem10,
	justification: 'center});
DefineGlobalConstant('kDrawStyleR,	// for AZfreq
	{font: ROM_fontSystem10,
	justification: 'right});
constant kDrawWidth  := 10; // M,W wider
constant kDrawHeight := 11;
constant kDrawOffsetY:=  2;

constant kCellWidth 	:= 22;	// width of a cell  (wide enough for M & W)
constant kCellHeight	:= 33;	// for protoCharEdit (high enough for code 
Å‚xÅ‚@underneath. viewLineSpacing+11)

DefineGlobalConstant('kTopMargin, (2 * kDrawHeight) - kDrawOffsetY);	// ok to overlap a little
DefineGlobalConstant('kBotMargin, 2 * kDrawHeight); 	// status bar


constant kSpace	 		:= $ ;
constant kHelpChar		:= $?;
constant kTooLongChar	:= $É;
constant kBreakWordChar	:= $~;
constant kNotEditable	:= $_;

DefineGlobalConstant('kAupper, Ord($A));
DefineGlobalConstant('kAlower, Ord($a));

constant kNumLetters:= 26;
constant kLastLetter:= 25;	// kNumLetters-1
constant kA
Å‚xÅ‚@lphabet	:= "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
DefineGlobalConstant('kAlphaPunc, kAlphabet & "?.,:;'()-!~\"");	// full editing
DefineGlobalConstant('kAlphabetQ, kAlphabet & kHelpChar);		// code editing w/ answer


constant kBookReaderSymbol		:= 'Copperfield;
//constant kHelpReaderSymbol	:= 'tinyTim;


DefineGlobalConstant('kMakeString, func(INT slen, fillCh) // like MakeArray
begin
	local str := MakeBinary((slen*2) + 2, 'string);
	local INT i;
	if fillCh
	then for i:=0 to slen-1 do str[i] := fillCh;
	str;

Å‚xÅ‚@end);


/*
DefineGlobalConstant('kUpchar, func(ch)
begin
	local INT code := Ord(ch) - kAlower;
	if code >= 0 and code <= kLastLetter
	then kAlphabet[code]	//Chr(code + kAupper)
	else ch;
end);
*/

DefineGlobalConstant('kMyUpTrimString, func(str)
if IsString(str)
then begin
	// get rid of leading, trailing and extra blanks in middle
	// but also convert cr,tab to space; lowercase to uppercase

	str := StripInk(Clone(str), nil);
	local INT slen := StrLen(str), i := 0, code;
	local del, ch;
	while i < s
Å‚xÅ‚@len
	do begin
		if isWhiteSpace(ch := str[i])
		then begin
			if not del
			then str[del := i] := kSpace; // remember first "space" (convert)
			end

		else begin
			//str[i] := call kUpchar with (ch);
			if (code := Ord(ch) - kAlower) >= 0 and code <= kLastLetter
			then str[i] := kAlphabet[code];

			if del and (del=0 or (del := del+1) < i)
			then begin
				StrMunger(str, del, i-del, nil,0,nil);
				slen := slen-i+del; //StrLen(str);
				i := del-1;	// +1 below
				end;
			del := nil;
			end;
		i 
Å‚xÅ‚@:= i+1;
		end;

	if del	// trim end
	then StrMunger(str,del,nil, nil,0,nil);
	str;
	end
else str
);


DefineGlobalConstant('kStrBreakPos, func(str, INT spos, INT charWid)
begin	// return next "line" break position, given max charWid chars per line
	local INT slast := spos+charWid, slen := StrLen(str), i;

	if slast < slen
	then begin // break on whitespace, end or -
		if isWhiteSpace(str[slast])
		then return slast;

		for i := slast-1 to spos by -1
		do if not isAlphaNumeric(str[i])
		then return i;
Å‚xÅ‚@

		return slast-1;	// break arbitrarily
		end;
end);

// usually called via AddDeferredCall
DefineGlobalConstant('kResetLetters, func() // shared by viewSetupFormScript, setTextCode
GetRoot().(kAppSymbol).lettersUsed := Array(kNumLetters, NIL)
);

/*
DefineGlobalConstant('kIsUpper, func(ch)
begin
	//CharPos(kAlphabet, ch, 0)
	local INT code := Ord(ch) - kAupper;
	if code >= 0 and code <= kLastLetter
	then code;
end);
*/


// ----------
// Register

DefineGlobalConstant('kGetResource, func(name)
begi
Å‚xÅ‚@n
	local rsc := OpenResFileX(HOME & kAppName & ".rsc");
	local icon := GetPictAsBits(name,nil);
	CloseResFileX(rsc);
	icon;
end);

constant kRegistrationPackage := '|Register:FlaSheridn|;
constant kSharewareFee := 10.00;
DefineGlobalConstant('kRegisterIcon, call kGetResource with ("RegisterMoneyButton"));

DefineGlobalConstant('kRegFrame,
	{package: kAppSymbol, 
	price:	  kSharewareFee,
	platform: 'Newton, 
	Version:  kVersionString,
	notes:	 "Thanks for registering" && kAppName,
	});


// ----------
Å‚xÅ‚@
// Notes

constant kNotesSym 			:= 'paperroll;
constant kNotesName			:= "Notes";

DefineGlobalConstant ('kSourcePath,'[pathExpr: data,0,text]);

DefineGlobalConstant('kNotesGetTitle, func(target)
// for GetTitle slot of routeframe
if target and IsString(target.(kSourcePath))
then kAppName
);


DefineGlobalConstant('kNotesRouteScript, func(target,targetView)
if target
then begin
	local root := GetRoot();
	root.(kNotesSym):close();
	root.(kAppSymbol):newCode(kNotesName & $: && target.title, nil, targe
Å‚xÅ‚@t.(kSourcePath), nil);
	end
);


DefineGlobalConstant('kNotesRouteItem, { // for routeScript array (GetRouteScripts)
GetTitle: 			kNotesGetTitle,
icon:				call kGetResource with ("cipherSmallicon"), // rename?
tag:				kAppSymbol,
routeScript:		kNotesRouteScript,
});


DefineGlobalConstant('kNotesProtoItem, { // for Notes _proto chain
GetRouteScripts:	func(targetInfo)
begin
	local routes := [kNotesRouteItem], oldRoutes;
	if oldRoutes := inherited:?GetRouteScripts(targetInfo)
	then routes := SetUnion(r
Å‚xÅ‚@outes, oldRoutes, true);
	SetUnion(routes, routeScripts, true);
end
});


// ----------
// NewtWorks

constant kNewtWorksSym		:= 'NewtWorks;
constant kNewtWorksName		:= "NewtWorks";

DefineGlobalConstant('kNewtWorksDoItFunc, func(viewDefView, newtAppBase)	// newtAppBase is unused
begin
	// check if anything is selected
	local range := viewDefView:GetHiliteRange();

	// if nothing is selected, treat it as 'Select All'
	if range.first = range.last
	then begin
	  	range.first := 0 ;
	  	range.last 	:= v
Å‚xÅ‚@iewDefView:GetCountCharacters() ;
		end;
	local str := viewDefView:GetRangeData(range, 'text);
	local title := newtAppBase.target.title;

	//local root := GetRoot();
	newtAppBase:close(); //root.(kNewtWorksSym):close();
	GetRoot().(kAppSymbol):newCode(kNewtWorksName & $: && title, nil, str, nil);
end);


DefineGlobalConstant('kToolFrame,	{ // see Rot13 example
dataTypeSymbol: 'paper,		// REQUIRED: ('paper for word processor; 'drawPaper for drawing app)

item: 			kAppName,	// REQUIRED: appears in popu
Å‚xÅ‚@p in tool picker.

/*
keyCommand: {				// optional
	char:		$1,			// cmd-!
	showchar:	$!,
	modifiers:	kCommandModifier,	//1 << 25
	keyMessage:	Intern("Do" & kAppName),

	keyFn:		func(viewDefView)
					call kNewtWorksDoItFunc with (viewDefView, nil),	// newtAppBase is unused
	name:		kAppName,
	category:	"General",
	},
*/

// REQUIRED: called when user selects the item in the Tools picker
cmdFunc:	kNewtWorksDoItFunc,
});


// ----------
// Extras

constant kExtrasSym	:= 'extrasDrawer;

DefineGlobalConst
Å‚xÅ‚@ant('kExtrasProtoItem, { // for Extras _proto chain
getIndex: func(dropPt) // return index into visibleItems
begin
	local INT index := (dropPt.y - :GlobalBox().top - 22) div vSpacing;
	if overUp
	then index	// overview
	else begin	// icon view
		local lb := :LocalBox(), cols := (lb.right - lb.left) div hSpacing;
		(index * cols) + (dropPt.x div hSpacing);
		end;
end,

viewGetDropTypesScript: func(dropPt)
begin
//Print(dropPt);
	local INT index := :getIndex(dropPt);
//Print(index);

	if index >= 0 and
Å‚xÅ‚@ index < Length(visibleItems)
		and visibleItems[index].fEntry.app = kAppSymbol
	then begin
		local app := GetRoot().(kAppSymbol);
		app.extrasIndex := index;	// stash for viewDropScript test
		app:viewGetDropTypesScript(dropPt);
		end
	else inherited:?viewGetDropTypesScript(dropPt);
end,

viewFindTargetScript: func(dragInfo)
if SetContains(dragInfo[0].types, 'text)
then self
else inherited:?viewFindTargetScript(dragInfo),


//viewDragFeedBackScript:	func(dragInfo,currentPoint,show) nil,	// no drawin
Å‚xÅ‚@g occurred

viewDropScript: func(dropType, dropData, dropPt)
begin
	local app := GetRoot().(kAppSymbol);
	if app.extrasIndex = :getIndex(dropPt)
	then app:newCode("drop app(code)", nil, dropData.text, nil)
	else inherited:?viewDropScript(dropType, dropData, dropPt);
end,

//viewDropDoneScript:		func() nil,
});


// ----------

DefineGlobalConstant ('kAddPatchFunc, func(target, template)
if target
then begin
	// init the patch
	local patch := EnsureInternal({}), sym, val;

	// copy all of the patched 
Å‚xÅ‚@slots (including tag)
	foreach sym, val in template
	do patch.(EnsureInternal(sym)) := val;

	patch.(EnsureInternal('tag)) := EnsureInternal(kAppSymbol);

	// link into the target's proto chain
	patch.(EnsureInternal('_proto)) := target._proto;
	target._proto := patch; // returns patch
	end
);


DefineGlobalConstant('kRemovePatchFunc, func(target)
begin
	local nextProto;
	if target
	then while nextProto := target._proto
	do  if nextProto.tag = kAppSymbol
		then break target._proto := nextProto._proto
Å‚xÅ‚@
		else target := nextProto;
end
);


// ----------


InstallScript := func(partFrame)
begin
	local root := GetRoot();
	call kAddPatchFunc with (root.(kNotesSym),   kNotesProtoItem);
	call kAddPatchFunc with (root.(kExtrasSym), kExtrasProtoItem);

	root.(kNewtWorksSym):?RegNewtWorksTool(EnsureInternal(kAppSymbol), kToolFrame);

	//if kDebugOn then
	//AddDeferredCall(func() root.(kAppSymbol):open(), nil);
end;


RemoveScript := func(partFrame)
begin
	local root := GetRoot();
	call kRemovePatchFunc wit
Å‚xÅ‚@h (root.(kNotesSym));
	call kRemovePatchFunc with (root.(kExtrasSym));
	root.(kNewtWorksSym):?UnRegNewtWorksTool(kAppSymbol);
end;

/* TO DO?
- insert gesture/drag letters to move over?
- mask for cipherIcon?
- lowercase testing
- performance
*/

/*
getroot().|Crypto:TKnollSys|.codearea:getchildviews()[0]
*/

ol), kToolFrame);

	//if kDebugOn then
	//AddDeferredCall(func() root.(kAppSymbol):open(), nil);
end;


RemoveScript := func(partFrame)
begin
	local root := GetRoot();
	call kRemovePatchFunc wit
// End of text file Project Data
// Beginning of file protoCryptoCharEdit
_v393_0 :=
    {viewBounds: {left: 0, top: 0, right: 0, bottom: 56},
     viewJustify: 8240,
     viewDrawScript:
       func()
begin
	inherited:?viewDrawScript();
	if codeLabels	// see setTextCode
	then :DrawShape(codeLabels, kDrawStyle);
end
       ,
     viewSetupFormScript:
       func()
begin
	// see setTextCode
	text := Clone(self.oldText := self.codeText := self.answerText := blankString);
	template := fullLineTemplate;
	inherited:?viewSetupFormScript();
end
       ,
     viewLineSpacing: 22,
     displayExternal:
       func(doIt)
if StrFilled(codeText)
	and not StrEqual(codeText, blankString)
	and StrExactCompare(text, oldText) <> 0
then begin
//Print("displayExternal:" && text);
//Print(oldText);
//Print(codeText);
	local INT i, inew;
	local redisplay, newChar, oldChar, codeChar;
	local ARRAY newChars := [], oldChars := [], codeChars := [];

	// what happens if lowercase sneaks in???
	for i := 0 to StrLen(codeText)-1
	do  if (codeChar := codeText[i]) <> kSpace
			and (newChar := text[i]) <> (oldChar := oldText[i])
			and newChar <> codeChar		// !!! 1.1
		then if newChar = kSpace
				or ((inew := CharPos(kAlphabet, newChar, 0)) //call kIsUpper with (newChar))
					and not lettersUsed[inew])
			then begin	
				if not SetContains(codeChars, codeChar)
				then begin
					AddArraySlot(newChars, newChar);
					AddArraySlot(oldChars, oldChar);
					AddArraySlot(codeChars, codeChar)
					end;
				end

			else if newChar = kHelpChar and (newChar := answerText[i])
			then begin
				if oldChar := lettersUsed[CharPos(kAlphabet, newChar, 0)]
				then begin // answer letter already used elsewhere (zap it)
					AddArraySlot(newChars, kSpace);
					AddArraySlot(codeChars, oldChar);
					end;
				AddArraySlot(newChars, newChar);
				AddArraySlot(codeChars, codeChar);
				end

			else text[i] := redisplay := oldChar;		// invalid or already used; local 'undo'

	oldText := Clone(text);				// update (prevent recursion?)

	if Length(codeChars) > 0
	then begin
//Print([newChars]);
		if Length(oldChars) > 0
		then crypto:AddUndoAction('substitute, [oldChars, codeChars]);
		crypto:substitute(newChars, codeChars); 					// substitute globally
		end;

	if redisplay
	then begin
		//:SetNewWord(text, nil);	// set it (not nec?)

		:Dirty();
		//:UseNewWord();			// redisplay this line
		:SysBeep();
		end;
	end
       ,
     substitute:
       func(ARRAY newChars, ARRAY codeChars)
if StrFilled(codeText) and not StrEqual(codeText, blankString)
then begin
//Print("protoCharEdit substitute:" && codeText);
	local pos, sub, codeChar, newChar;
	local INT i;
	for i := 0 to Length(codeChars)-1
	do begin
		codeChar := codeChars[i];
		newChar	 := newChars[i];
		pos := -1;
		while pos := CharPos(codeText, codeChar, pos+1)
		do text[pos] := sub := newChar;
		end;

	if sub							// changed?
	then begin
		oldText := Clone(text);		// save
		:SetNewWord(text, nil);		// set it
		:UseNewWord();				// redisplay
		end;
	end
       ,
     setTextCode:
       func(txt, ctxt, atxt)
begin
	local oldCodeText := codeText;
	if IsString(ctxt)
	then codeText := ctxt
	else if not ctxt
	then codeText := blankString;

	if IsString(atxt)
	then answerText := atxt
	else if not atxt
	then answerText := blankString;

	local oldTemplate := template;

	if StrEqual(codeText, oldCodeText)
	then // no change in code
		text := Clone(oldText := if txt then txt else template.string)

	else begin
		text := Clone(oldText := if txt then txt else blankString);
		codeLabels := NIL;

		if StrEqual(codeText, blankString)
		then template := fullLineTemplate	// edit everything

		else if not StrFilled(codeText)
		then template := emptyLineTemplate // edit nothing

		else begin // edit some
			local fmt := Clone(fullLineTemplate.format), ch, sub;
			local INT i, slen := StrLen(codeText);
			local INT x1 := dispIndent, x2, y1 := cellHeight-8, y2 := cellHeight;
			codeLabels := [];
			for i := 0 to maxCols-1
			do begin
				x2 := x1 + cellWidth;
				if i < slen and CharPos(kAlphabet, ch := codeText[i], 0)
				then AddArraySlot(codeLabels, MakeText(SPrintObject(ch), x1, y1, x2, y2))
				else begin
					fmt[i] := kNotEditable;
					if i < slen
					then text[i] := sub := ch;	// display char (otherwise blank)
					end;
				x1 := x2;
				end;

			template := {
				filters: [if answerText = blankString then kAlphabet else kAlphabetQ],
				format: fmt,
				string: if sub then oldText := Clone(text) else oldText,
				};
			end;
		end;

	// update
	if template = oldTemplate
	then begin
		:SetNewWord(text, nil);		// save, set it
		:UseNewWord();				// redisplay (w/ same template)
		end
	else :UseTextAndTemplate();
end
       ,
     codeLabels: nil,
     viewClickScript:
       func(unit)
begin
	local INT x := GetPoint(firstX,unit) - :GlobalBox().left, cellNum := (x-dispIndent) div cellWidth;
	local ch;
//Print(x); Print(cellNum);

	// save either code substitution, or cell location
	crypto.nextSub :=
		if cellNum < StrLen(codeText) and CharPos(kAlphabet, ch := codeText[cellNum], 0)
		then [self, cellNum, ch]
		else if template.filters = fullLineTemplate.filters	// clone may have occurred during :useTextAndTemplate?
		then [self, cellNum, NIL];
//Print(crypto.nextSub);

	inherited:?viewClickScript(unit);
end
       ,
     _proto: @393 /* protoCharEdit */
    };

// After Script for _v393_0
thisView := _v393_0;
begin
	thisView.cellWidth  := kCellWidth;
	thisView.viewBounds.bottom := thisView.cellHeight := kCellHeight;
end


constant |layout_protoCryptoCharEdit| := _v393_0;
// End of file protoCryptoCharEdit
// Beginning of file helpLayout
helpLayout :=
    {viewBounds: {left: 0, top: -238, right: 240, bottom: 0},
     viewJustify: 144,
     declareSelf: 'base,
     viewFormat: 593,
     viewFlags: 96,
     _proto: @173 /* protoDrawer */
    };

helpLayout_v81_0 :=
    {viewBounds: {left: 1, top: 1, right: -1, bottom: -15},
     viewFlags: 1,
     viewFont:
       simpleFont10 // note: this will be replaced by styles. coord with linespacing
       ,
     viewFormat: 257,
     viewLineSpacing: 12,
     text: kHelpText,
     viewJustify: 240
     ,
     viewClass: 81 /* clParagraphView */
    };
AddStepForm(helpLayout, helpLayout_v81_0);



helpLayout_v166_0 := {_proto: @166 /* protoCloseBox */};
AddStepForm(helpLayout, helpLayout_v166_0);




constant |layout_helpLayout| := helpLayout;
// End of file helpLayout
// Beginning of file protoAboutText

// Before Script for _v81_0
begin

constant kNewtsCapeSymbol	:= '|Newtscape:Newtscape|;
DefConst('kBuild20, platformVersion.platformFile <> '|MessagePad|);

DefConst('kFixupHREFtext, func(template) // used in instance's afterScript
begin
	// extract&remove HREF info, emphasize URLs with underline
	// this version assumes syntactically correct URLs (no extra/missing chars)
	// <A HREF="href">label</A>
	// e.g., <A HREF="http://">home page</A>
	// e.g., <A HREF="mailto:...">email addr</A>
	local ARRAY styles := [], hrefs := [];
	local text := template.text, href;
	local regfont := template.viewFont, urlfont;
	if isFrame(regfont)
	then begin
		urlfont := Clone(regfont);
		urlfont.face := BOR(urlfont.face, kFaceUnderline);
		end
	else urlfont := BOR(regfont,tsUnderLine);

	local spos, qpos, epos := 0;

	while spos := StrPos(text, "<A HREF", epos)
	do begin
		// non-empty regular text before <A...
		if spos > epos
		then begin
			AddArraySlot(styles, spos-epos);
			AddArraySlot(styles, regfont);
			end;

		// extract href string: "http:..."
		qpos := StrPos(text,"\"",spos)+1;
		epos := StrPos(text,"\"",qpos);
		href := SubStr(text,qpos,epos-qpos);

		// remove HTML before label: <A HREF="...">
		epos := StrPos(text, ">", epos);
		StrMunger(text,spos,epos+1-spos, nil,0,nil);

		// remove HTML after label: </A>
		epos := StrPos(text,"</A>",spos);
		StrMunger(text,epos,4, nil,0,nil);

		// highlight label
		AddArraySlot(styles, epos-spos);
		AddArraySlot(styles, urlfont);

		// save href (for viewClickScript)
		AddArraySlot(hrefs, [href, spos, epos]);
		end;

	// any regular text at end?
	if epos < StrLen(text)
	then begin
		AddArraySlot(styles,StrLen(text)-epos);
		AddArraySlot(styles, regfont);
		end;

if kDebugOn
then begin
	Print("about text:");	Print(text);
	Print("about hrefs:");	Print(hrefs);
	end;

	template.styles := styles;
	template.hrefs := hrefs;
	template.text := text;
	RemoveSlot(template,'viewFont);
end);

end


_v81_0 :=
    {viewBounds: {left: 1, top: 1, right: -1, bottom: -15},
     viewFlags: 513,
     viewFont:
       simpleFont10 // note: this will be replaced by styles. coord with linespacing
       ,
     viewFormat: 257,
     viewLineSpacing: 12,
     text: "",
     viewClickScript:
       func(unit)
begin
/*
	this finds the HREF that's clicked on (precomputed in afterScript)
	highlights it
	dispatches via urlCop or Newt's Cape
	unhighlights
*/

	local hrefentry, href, options := {}, spos, epos, app;
	local INT cpos := :MyPointToCharOffset(GetPoint(firstX,unit), GetPoint(firstY,unit));

//Print(cpos);
//if cpos >=0 then Print(text[cpos]);

	if cpos >= 0
	then foreach hrefentry in hrefs // e.g., [["http:...", 10,20],...]
		do if (spos := hrefentry[1]) <= cpos and
				cpos <= (epos := hrefentry[2])
		then begin
			:SetHilite(spos, epos, true);
			href := hrefEntry[0];

			// dispatch using urlCop if installed (and url type is registered)
			if (app := GetRoot().urlCop:?PreferredApp(href, 'getURL, {}))
				and app <> kNewtsCapeSymbol
			then GetRoot().urlCop:getURL(href,options) // .(app): ?

			else if GetRoot().(kNewtsCapeSymbol) // Newt's Cape installed?
			then begin
				if BeginsWith(href,"mailto:")
				then begin
					options.subject := title; // from app
					options.name 	:= SubStr(text,spos,epos-spos);
					options.body 	:= "I really like" && title;
					end;
				//else options.noStatus := not kDebugOn; // hidden for end users?
				GetRoot().(kNewtsCapeSymbol):getURL(href,options);
				end
			else if kDebugOn
			then Print(href);

			break :SetHilite(cpos,cpos,true); // would be nice to get rid of the caret too
			end;
	TRUE; // handled click
end
       ,
     viewJustify: 240,
     MyPointToCharOffset:
       func(x,y) 
if kBuild20 or HasVariable(self, 'PointToCharOffset)
then :PointToCharOffset(x,y)

else begin // 1.x definition
	local gb := :GlobalBox();
	x := x - gb.left;
	y := y - gb.top;
	//Print([x,y]);

	local spos, epos := -1;
	local INT i, linenum := y div viewLineSpacing;
	if linenum < 0 then return -1;

	// find the line
	// assume all cr-delimited with no wrapping
	for i:=0 to linenum
	do if epos
		then begin
			spos := epos+1;
			epos := StrPos(text,"\n",spos);
			end
		else return -1;

	local newstr := {
		viewFont: styles[1],
		msg: Functions.StrTruncate}:msg(SubStr(text,spos,epos), x);

	spos + StrLen(newstr)-1; // É on end
	end
       ,
     viewClass: 81 /* clParagraphView */
    };


constant |layout_protoAboutText| := _v81_0;
// End of file protoAboutText
// Beginning of file aboutLayout
aboutLayout :=
    {viewBounds: {left: 0, top: -238, right: 240, bottom: 0},
     declareSelf: 'base,
     viewJustify: 144,
     viewFormat: 593,
     viewFlags: 96,
     _proto: @173 /* protoDrawer */
    };

aboutLayout_v0_0 :=
    {text: kAboutText,
     viewBounds: {left: 2, top: 5, right: -2, bottom: -15},
     _proto: _v81_0
    };
AddStepForm(aboutLayout, aboutLayout_v0_0);

// After Script for aboutLayout_v0_0
thisView := aboutLayout_v0_0;
begin
	call kFixupHREFtext with (thisView);
	local styles := thisView.styles;
	local tlen := StrLen(kTitle);	// "heading"
	ArrayMunger(
		styles, 0, 1,
		[tlen, ROM_fontSystem18Bold, styles[0] - tlen], 0, 3);
end




aboutLayout_v166_0 := {_proto: @166 /* protoCloseBox */};
AddStepForm(aboutLayout, aboutLayout_v166_0);




constant |layout_aboutLayout| := aboutLayout;
// End of file aboutLayout
// Beginning of file CryptoMainLayout
Crypto :=
    {newtworksRoute: func(target, targetView)
:refreshApp(kNewtWorksSym),
     newtscapeRoute: func(target, targetView)
:refreshApp(kNewtsCapeSym),
     sharewareFee: kSharewareFee,
     viewFormat: 1,
     viewQuitScript:
       func()
begin
	ClearUndoStacks();
	lettersUsed := letterFreq := nextSub := curSoupTitles := curAnswer := NIL;

	//inherited:?viewQuitScript();
end
       ,
     clearAnswerRoute:
       func(target, targetView)
begin
	//:AddUndoAction('setTextCode, codeArea:getTextCode(Array(maxRows, nil), true));
	ClearUndoStacks();
	:setTextCode(nil, nil, true, true);		// erase text, preserve code & answer
end
/*
note: to implement undo properly for commands, need to save/restore 'lines';
need to reimplement/test protoCryptoCharEdit:setTextCode
also save/restore lettersUsed/letterFreq?
*/
       ,
     ViewGetDropTypesScript: func(currentPoint)
'[text],
     viewFlags: 516,
     ReorientToScreen: ROM_DefRotateFunc,
     encodeRoute:
       func(target, targetView)
begin
	local text := call kMyUpTrimString with (codeArea:getTextCode("", true)[0]);
	//:AddUndoAction('setTextCode, oldTextCode);
	ClearUndoStacks();
	:setTextCode(
		nil,
		:encodeString(text, nil),	// fix/replace text
		nil,						// zap code
		if curAnswer
		then true					// already set (earlier encode)
		else curAnswer := text 		// set answer
		);
end
       ,
     ViewFindTargetScript:
       func(dragInfo) //return a view frame of the view that should get the drop messages.
codeArea
       ,
     viewBounds: {left: 0, top: 0, right: 0, bottom: 0},
     curAnswer: nil,
     letterFreq: nil,
     deleteRoute:
       func(target, targetView)
begin
	//:AddUndoAction('setTextCode, codeArea:getTextCode(Array(maxRows, nil), Array(maxRows, nil)));
	ClearUndoStacks();
	crypto:Delete('setTextCode, [nil, nil, nil, curAnswer := nil]);	// erase title, text, code, answer
end
       ,
     notesRoute: func(target, targetView)
:refreshApp(kNotesSym),
     newCode:
       func(title, text, codeText, ansText)
begin
	:open(); //:refreshApp(self);
	curAnswer := NIL;
	ansText := call kMyUpTrimString with (ansText);
	if IsString(codeText) and not StrFilled(codeText) and StrFilled(ansText)
	then codeText := :encodeString(ansText, nil);
	:setTextCode(
		call kMyUpTrimString with (title),
		call kMyUpTrimString with (text),
		call kMyUpTrimString with (codeText),
		ansText
		);
end
       ,
     viewJustify: 240,
     lettersUsed: nil,
     curSoupTitles: nil,
     setChar:
       func(line, cellNum, ch) // primarily for AZkey
begin
	line.text[cellNum] := ch;
	line:SetNewWord(line.text, nil);
	line:UseNewWord();
end
       ,
     setTextCode:
       func(title, text, codeText, ansText)
if call kViewIsOpenFunc with (self)	// in case already closed
then begin
//Print("setTextCode:" && text);
	local INT i;
	lettersUsed := Array(kNumLetters, NIL);
	if StrFilled(title)	// save?
	then begin
		// for now just display title temporarily under A-Z
		for i:=0 to min(kLastLetter, StrLen(title)-1)
		do lettersUsed[i] := title[i];
		// avoid interfering with text entry (see viewSetupFormScript)
		AddDeferredAction(kResetLetters, nil);
		end;

	local oldFreq := letterFreq, code;
	if IsString(ansText)
	then if StrFilled(ansText)
		then AZKey:setTop(nil, code := kAlphabetQ)
		else ansText := NIL;
	if not code
	then AZKey:setTop(nil, if ansText then kAlphabetQ else if codeText then kAlphabet else kAlphaPunc);
	AZKey:dirty();

	if IsString(codeText)
	then begin
		letterFreq := Array(kNumLetters, NIL);
		for i := 0 to kLastLetter
		do letterFreq[i] := [0, kAlphabet[i]];	// for sorting
		for i := 0 to StrLen(codeText)-1
		do  if code := CharPos(kAlphabet, codeText[i], 0) //call kIsUpper with (codeText[i])
			then letterFreq[code][0] := letterFreq[code][0]+1;
		Sort(letterFreq, '|>|, '[pathExpr: 0]);
		end
	else if not codeText
	then letterFreq := NIL;
	
	if oldFreq <> letterFreq
	then AZfreq:dirty();

	// make UPPERCASE. get rid of extra leading/trailing spaces etc.
	codeArea:setTextCode(text, codeText, ansText);
	TRUE;	// for viewDropScript
	end
       ,
     maxCols: nil,
     moveCodeRoute:
       func(target, targetView)
begin
	local oldTextCode := codeArea:getTextCode("", nil);
	//:AddUndoAction('setTextCode, oldTextCode);
	ClearUndoStacks();
	:setTextCode(nil, nil, call kMyUpTrimString with (oldTextCode[0]), true);	// erase text, use fixed text as code, save answer (if any)
end
       ,
     maxRows: nil,
     declareSelf: 'base,
     viewSetupFormScript:
       func()
begin
	self.(kNameSym) := self.newtAppBase := self;	// crypto used in various places
	local ap := GetAppParams();
	// figure max cols and rows based on current screen size
	maxCols := ap.AppAreaWidth div kCellWidth;
	maxRows := (ap.AppAreaHeight  - kTopMargin  - kBotMargin) div kCellHeight;
	//maxChild := maxCols * maxRows;

	letterFreq := NIL;
	lettersUsed := Array(kNumLetters, NIL);

	local INT i;
	for i := 0 to StrLen(kUPNAME)-1
	do lettersUsed[i*5] := kUPNAME[i]; 	// C..R..Y..P..T..O

	// leave visible but avoid interfering with initial text entry
	AddDeferredAction(kResetLetters, nil);

	//inherited:?viewSetupFormScript();
end
       ,
     routeScripts:
       begin
local rsc := OpenResFileX(HOME & kAppName & ".rsc");
local rf := {       
clearAnswer: {
	title: 			"Clear Answer",
	icon: 			GetPictAsBits("clearAnswer",nil),
	routeScript: 	'clearAnswerRoute,
	},

encode: {
	title: 			"Encode",
	icon:			GetPictAsBits("encode",nil),
	routeScript: 	'encodeRoute,
	},

moveCode: {
	title: 			"Move to Code",
	icon:			GetPictAsBits("moveCode",nil),
	routeScript: 	'moveCodeRoute,
	},

divider1: NIL,

cryptoSoup:	{
	GetTitle:		func(target)
					if GetUnionSoup(kSoupName) then kAppName && "Soup...",
	routeScript:	'cryptoSoupRoute,
	},

save: {
	title: 			"Save Code to" && kNotesName,
	icon: 			@717,			// undoc???
	routeScript: 	'saveRoute,
	},

divider2: NIL,

delete: {
	title: 			"Delete",
	icon: 			ROM_routeDeleteIcon,
	routeScript:	'deleteRoute,
	},

divider3: NIL,

notes:	{
	title:			kOpen && kNotesName,
	//GetTitle:		func(target) if GetRoot().(kNotesSym) then kOpen && kNotesName,
	routeScript:	'notesRoute,
	},

newtworks:	{
	GetTitle:		func(target)
					if GetRoot().(kNewtWorksSym) then kOpen && kNewtWorksName,
	routeScript:	'newtworksRoute,
	},

newtscape:	{
	GetTitle:		func(target)
					if GetRoot().(kNewtsCapeSym) then kOpen && kNewtsCapeName,
	icon:			GetPictAsBits("NewtsCape NIE tiny", nil),
	routeScript:	'newtscapeRoute,
	},
};

CloseResFileX(rsc);
rf;
end
       ,
     refreshApp:
       func(app)	// bring app to top (Notes, Newtworks, Newt's Cape)
begin
	crypto:hide();
	if IsSymbol(app)
	then app := GetRoot().(app);
	if app and call kViewIsOpenFunc with (app)
	then app:hide();
	app:?open();
end
       ,
     nextSub: nil,
     generateKey:
       func()
begin
	// create a random key
	local INT i, r;
	local ch, key := Clone(kAlphabet);
	for i := 0 to kLastLetter
	do  if (ch := key[i]) = kAlphabet[i] 	// char still in original position?
		then begin
			// switch with a different letter
			repeat (r := Random(0,kLastLetter)) until r <> i;
			key[i] := key[r];
			key[r] := ch;
			end;
	key;
end
       ,
     pickActionScript:
       func(cmd)
begin
	local entry := ResolveEntryAlias(curSoupTitles[cmd].value);
	crypto:newCode(entry.title, nil, entry.code, entry.answer);
end
     ,
     viewClass: 74 /* clView */,
     encodeString:
       func(str, key)
begin
	if not key
	then key := :generateKey();
	local INT i, code;

//	foreach is,str in if IsArray(s) then s else [s]
//	do begin

		str := Clone(str);

		for i := 0 to StrLen(str)-1
		do  if code := CharPos(kAlphabet, str[i], 0) //call kIsUpper with (str[i])
			then str[i] := key[code];

//		if IsArray(s)
//		then s[is] := str
//		else s := str;
//		end;

	str;
end
       ,
     saveRoute:
       func(target, targetView)
GetRoot().(kNotesSym):makeTextNote(codeArea:getTextCode(nil, "")[1], true)
     ,
     substitute:
       func(ARRAY newChars, ARRAY codeChars)
begin
	call kShowBusyBoxFunc with (nil);
	local INT i, last := Length(codeChars)-1;
	local code;
	for i:=0 to last
	do  if code := SetContains(lettersUsed, codeChars[i])
		then lettersUsed[code] := NIL;				// turn off old mapping

	for i:=0 to last
	do	if code := CharPos(kAlphabet, newChars[i], 0)
			//(char := newChars[i]) <> kSpace
			//and code := call kIsUpper with (char)
		then lettersUsed[code] := codeChars[i];		// turn on new mapping

	AZkey:dirty();									// update key
	codeArea:substitute(newChars, codeChars);		// substitute in all lines
end
       ,
     cryptoSoupRoute:
       func(target, targetView)
begin
	local items := crypto.curSoupTitles;
	if not items
	then begin
		crypto.curSoupTitles := items := [];
		gc();
		local cursor := GetUnionSoup(kSoupName):query(nil), entry := cursor:entry();
		while entry
		do begin
			AddArraySlot(items, {item: entry.title, value: MakeEntryAlias(entry)});
			entry := cursor:next();
			end;
		Sort(items, '|str<|, 'item);
		end;

	local gb := :GlobalBox();
	crypto:PopupMenu(items, {left: gb.left, top: gb.top});
end
    };

AZkey :=
    {viewBounds: {left: 0, top: 0, right: 234, bottom: 20},
     viewFlags: 513,
     viewFormat: 1,
     viewDrawScript:
       func()
begin // overlap y a little; overlap x a little except full kAlphaPunc on landscape MP2K/eMate
	:DrawShape(AZtop, kDrawStyle);

	local INT i, x1 := 0, x2;
	//local INT y1 :=   -kDrawOffsetY, y2 :=    kDrawHeight-kDrawOffsetY;
	local INT y3 := kDrawHeight-kDrawOffsetY, y4 := y3+kDrawHeight-kDrawOffsetY; // y3 := y2
	local ch;
	for i := 0 to kLastLetter
	do begin
		x2 := x1 + kDrawWidth;
		if ch := lettersUsed[i]
		then :DrawShape(
			MakeText(SPrintObject(ch), x1, y3, x2, y4),
			kDrawStyle);
		x1 := x2 - offset;
		end;
end
       ,
     viewJustify: 16,
     viewSetupFormScript:
       func()
begin
	local INT len := StrLen(kAlphaPunc), wid := GetAppParams().appAreaWidth;
	if (len * kDrawWidth) > wid
	then len := wid div (kDrawWidth - offset := 1);
	self.viewBounds := RelBounds(0,0, len * (kDrawWidth-offset), (2 * kDrawHeight) - kDrawOffsetY);

	self.AZtop := [];			// lengthened in setTop
	:setTop(len, kAlphaPunc);	// for initial entry

	//inherited:?viewSetupFormScript();
end
       ,
     offset: 0,
     viewClickScript:
       func(unit)
begin
	local gb := :GlobalBox();
	local INT x := (GetPoint(firstX,unit) - gb.left) div (kDrawWidth-offset);
//Print(x);

	if nextSub
		and (GetPoint(firstY,unit) - gb.top) <= kDrawHeight	// top row?
		and (x > kLastLetter or not lettersUsed[x])			// punctuation, or not already used
	then begin
		local line := nextSub[0], text := line.text, cellNum := nextSub[1], codeChar := nextSub[2];
		local text := line.text, oldChar := text[cellNum], newChar := curAlpha[x];
		if codeChar and x <= kLastLetter
		then begin
			crypto:AddUndoAction('substitute, [[oldChar], [codeChar]]);
			crypto:substitute([newChar], [codeChar]);
			end

		else if codeChar and newChar = kHelpChar
		then if oldChar := lettersUsed[CharPos(kAlphabet, newChar := line.answerText[cellNum], 0)]
			then crypto:substitute([kSpace, newChar], [oldChar, codeChar])
			else crypto:substitute([newChar], [codeChar])

		else begin
			crypto:AddUndoAction('setChar, [line, cellNum, oldChar]);
			:setChar(line, cellNum, newChar);
			end;
		return TRUE;
		end;
	NIL;
end
       ,
     setTop:
       func(len, alphaStr)
begin	// set top row based on an alphabet string (kAlphabet, kAlphaPunc, kAlphabetQ)
	self.curAlpha := alphaStr;
	if not len
	then len := min(StrLen(alphaStr), viewBounds.right div (kDrawWidth-offset));

	local INT y1 := -kDrawOffsetY, y2 := kDrawHeight-kDrawOffsetY;
	local INT startReplace := min(Length(AZtop), 26);
	local INT i, x1 := startReplace * (kDrawWidth - offset), x2;

	// adjust/cache top row. see viewDrawScript
	SetLength(AZtop, len);
	for i := startReplace to len-1
	do begin
		x2 := x1 + kDrawWidth;
		AZtop[i] := MakeText(SPrintObject(alphaStr[i]), x1, y1, x2, y2);
		x1 := x2 - offset;
		end;
end
       ,
     viewClass: 74 /* clView */
    };
AddStepForm(Crypto, AZkey);
StepDeclare(Crypto, AZkey, 'AZkey);

// After Script for AZkey
thisView := AZkey;
begin
	//thisView.viewBounds.right	:= kNumLetters * kDrawWidth;
	//thisView.viewBounds.bottom:= (2 * kDrawHeight) - kDrawOffsetY;
	RemoveSlot(thisView, 'viewBounds);
end




codeArea :=
    {viewBounds: {left: 0, top: 45, right: 0, bottom: -25},
     viewFlags: 1,
     viewFormat: 1,
     viewJustify: 240,
     viewSetupChildrenScript:
       func()
begin
	// share these
	self.blankString := call kMakeString with (maxCols, kSpace);

	self.fullLineTemplate := {
		filters: [kAlphaPunc],
		format: call kMakeString with (maxCols, $0),
		string: blankString,
		};

	self.emptyLineTemplate := {
		filters: [],
		format: call kMakeString with (maxCols, kNotEditable),
		string: blankString,
		};

	self.stepChildren := SetClass(
		Array(maxRows, GetLayout("proto" & kAppName & "CharEdit")),
		'stepChildren);
end
       ,
     getChildViews:
       func()
if childViews
then childViews
else childViews := :childViewFrames()
     ,
     childViews: nil,
     substitute:
       func(ARRAY newChars, ARRAY codeChars)
begin
	local line;
	foreach line in :getChildViews()
	do line:substitute(newChars, codeChars);
end
     ,
     getTextCode:
       DefineGlobalConstant('kAppendLine, func(linestr, str) // str non-empty
begin
	local ch, delim;
	local INT slen := StrLen(str);
	if (ch := str[slen-1]) = kBreakWordChar		// remove ~
	then StrMunger(str,slen-1,1, nil,0,nil)
	else if ch <> $-
	then delim := kSpace;
	linestr & str & delim;
end
);

func(text, codeText)	// "", true or nil
begin
	local line, str;
	local INT i;
	foreach i,line in :getChildViews()
	do begin
		str := line.text;
		/*if isArray(text)
		then begin
			if not StrEqual(str,blankString) then text[i] := str; // else nil
			end
		else*/ if IsString(text) and str <> blankString
			and StrFilled(TrimString(str))
		then text := call kAppendLine with (text, str);

		str := line.codeText;
		/*if isArray(codeText)
		then begin
			if not StrEqual(str,blankString) then codeText[i] := str; // else nil
			end
		else*/ if IsString(codeText) and str <> blankString
			and StrFilled(str := TrimString(Clone(str)))
		then codeText := call kAppendLine with (codeText, str);

		end;
	[text, codeText];
end
       ,
     setTextCode:
       func(text, codeText, ansText)
begin
	local spos := 0, epos, lastBlank, line, linestr, ch, code;
	local INT linenum, slen;

	local ARRAY args := [text, codeText, ansText];
	local apath :=
		if IsString(text)
		then '[pathExpr: 0]
		else if IsString(codeText)
		then code := '[pathExpr: 1];
	local str := if apath then args.(apath);

	foreach linenum,line in :getChildViews()
	do begin
		if str	// split str into "lines"
		then if spos
			then begin
				epos := call kStrBreakPos with (str, spos, maxCols);
				lastBlank := not epos or (ch := str[epos]) = kSpace;
				linestr := SubStr(str, spos,
					if epos		// include break char?
					then (if lastBlank then epos else epos+1) - spos
					);

				slen := StrLen(linestr);
				if IsString(ansText)	// compute to same length
				then args[2] := SubStr(ansText, spos, slen);

				if not code and slen < maxCols
				then linestr := linestr & SubStr(blankString, 0, -slen + (slen := maxCols));

				if spos := epos
				then begin
					if linenum = maxRows-1
					then linestr[slen-1] := kTooLongChar		// code too longÉ
					else if isAlphaNumeric(ch)
					then linestr[slen-1] := kBreakWordChar;	// word broke~n

					if lastBlank then spos := epos+1;		// skip whitespace
					end;
				args.(apath) := linestr;
				end
			else begin
				args.(apath) := if code then "";			// hide remaining rows
				if IsString(ansText)
				then args[2] := nil;
				end;

		Perform(line, 'setTextCode, args);
		end;
end
       ,
     ViewDropScript:
       func(dropType, dropData, dropPt)
begin
	local line, str := call kMyUpTrimString with (dropData.text); // normally done in newCode
	local INT y := dropPt.y, bot;
	foreach line in :getChildViews()
	do if y < (bot := line:GlobalBox().bottom) - 8
		then return crypto:setTextCode("drop: answer", str, nil, nil) 	// text area

		else if y <= bot
		then return crypto:setTextCode("drop: code", nil, str, nil);	// code area
	NIL;
end
       ,
     viewClass: 74 /* clView */
    };
AddStepForm(Crypto, codeArea);
StepDeclare(Crypto, codeArea, 'codeArea);

// After Script for codeArea
thisView := codeArea;
begin
	//thisView.viewBounds.left 	:=  kLeftMargin;
	thisView.viewBounds.top 	:=  kTopMargin;
	//thisView.viewBounds.right := -kRightMargin;
	thisView.viewBounds.bottom	:= -kBotMargin;
end




statusBar :=
    {
     menuLeftButtons:
       [{_proto: protoInfoButton,
DoInfoAbout: func()
	aboutView:open(),
DoInfoHelp: func()
	begin
		local viewer := GetRoot().(kBookReaderSymbol);
		if viewer:whereIsBook(kBookISBN) // book installed?
		then viewer:openBook(kBookISBN)
		else helpView: open();
	end,

GenInfoAuxItems: func()
	if GetRoot().(kRegistrationPackage)
	then '["Example", "Register"] //{icon: kRegisterIcon, item: "Register"}]
	else '["Example"],

DoInfoAux: func(items, cmd)
if cmd=0
then begin	// example
	local str;
	crypto:setTextCode(
		"THE ANSWER", kSampleText, nil, nil);

	AddDelayedSend (crypto, 'setTextCode,	//'encodeRoute, [nil, nil],
		["ENCODED", str := :encodeString(kSampleText, nil), nil, nil], 3500);

	AddDelayedSend (crypto, 'setTextCode,	//'moveCodeRoute, [nil, nil]
		["READY TO SOLVE", nil, str, kSampleText], 5000);
	end

else /*if cmd=1 // and item[1].icon ?
then*/ begin
	local RegView := GetRoot().(kRegistrationPackage);
	RegView:open();
	RegView:ExternalRegister(kRegFrame);
	end,
},
]
       ,
     menuRightButtons: [newtActionButton],
     _proto: @401 /* newtStatusBar */
    };
AddStepForm(Crypto, statusBar);


aboutView := LinkedSubview(aboutLayout,
    {viewBounds: {left: 24, top: 24, right: 56, bottom: 40}});
AddStepForm(Crypto, aboutView);
StepDeclare(Crypto, aboutView, 'aboutView);
helpView := LinkedSubview(helpLayout,
    {viewBounds: {left: 80, top: 24, right: 112, bottom: 40}});
AddStepForm(Crypto, helpView);
StepDeclare(Crypto, helpView, 'helpView);

AZfreq :=
    {viewBounds: {left: 36, top: -20, right: -60, bottom: 0},
     viewFlags: 1,
     viewFormat: 337,
     viewDrawScript:
       func()
if letterFreq
then begin
	local INT i, x1 := 0, x2;
	local INT y1 :=   -kDrawOffsetY, y2 :=    kDrawHeight-kDrawOffsetY;
	local INT y3 := y2             , y4 := y3+kDrawHeight-kDrawOffsetY;
	for i := 0 to numFreq-1
	do begin
		if letterFreq[i][0] = 0
		then break;

		x2 := x1 + (kDrawWidth*2) - offset;
		:DrawShape(
			MakeText(SPrintObject(letterFreq[i][0]), x1, y1, x2, y2),
			kDrawStyleR);
		:DrawShape(
			MakeText(SPrintObject(letterFreq[i][1]), x1, y3, x2, y4),
			kDrawStyleR);
		x1 := x2;
		end;
	end
     ,
     viewJustify: 176,
     offset: 2,
     viewSetupFormScript:
       func()
begin
	local lb := :LocalBox();
//Print(lb);
	numFreq := (lb.right - lb.left) div (2 * (kDrawWidth-1));
//Print(numFreq);
	//inherited:?viewSetupFormScript();
end
       ,
     numFreq:
       8	// calculated in viewSetupFormScript
       ,
     viewClass: 74 /* clView */
    };
AddStepForm(Crypto, AZfreq);
StepDeclare(Crypto, AZfreq, 'AZfreq);

// After Script for AZfreq
thisView := AZfreq;
begin
	thisView.viewBounds.top		:= (-2 * kDrawHeight) + kDrawOffsetY;
	// each "char" is 2*kDrawWidth - 2 (= 18)
end





constant |layout_CryptoMainLayout| := Crypto;
// End of file CryptoMainLayout



